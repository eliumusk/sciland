#!/usr/bin/env bash
set -euo pipefail

# SciX Skill Directory MVP - production-ish deploy script
#
# What it does:
# - Generates strong secrets (Postgres/JWT/orchestrator keys)
# - Writes deploy env + nginx config + docker-compose file
# - Brings up stack via Docker Compose
# - Sets a strong password for the Postgres role (in-container) even if it was empty before
# - Exposes app via Nginx on :8080 (and :80 redirect -> :8080)
#
# Requirements:
# - Linux host with docker + docker compose plugin (or docker-compose)
# - Repo checked out on the server
# - Provide GitHub org + token for orchestrator repo creation:
#   export GITHUB_ORG="YourOrg"
#   export GITHUB_TOKEN="ghp_..."
#
# Usage:
#   bash deploy/deploy.sh

export GITHUB_ORG="SciX-Skill"
export GITHUB_TOKEN="ghp_xxx"

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DEPLOY_DIR="${ROOT_DIR}/deploy"

dc() {
  if docker compose version >/dev/null 2>&1; then
    docker compose "$@"
  elif command -v docker-compose >/dev/null 2>&1; then
    docker-compose "$@"
  else
    echo "ERROR: docker compose (plugin) or docker-compose is required." >&2
    exit 1
  fi
}

need_env() {
  local name="$1"
  if [[ -z "${!name:-}" ]]; then
    echo "ERROR: missing env var: ${name}" >&2
    exit 1
  fi
}

rand_hex() {
  local nbytes="$1"
  if command -v openssl >/dev/null 2>&1; then
    openssl rand -hex "${nbytes}"
  else
    # shellcheck disable=SC2005
    echo "$(head -c "${nbytes}" /dev/urandom | od -An -tx1 | tr -d ' \n')"
  fi
}

need_env GITHUB_ORG
need_env GITHUB_TOKEN

PUBLIC_HOST="${PUBLIC_HOST:-39.100.114.25}"     # used for BASE_URL and nginx redirect target
PUBLIC_PORT="${PUBLIC_PORT:-8080}"              # nginx listen port exposed publicly
REDIRECT_FROM_80="${REDIRECT_FROM_80:-1}"       # 1 => nginx also listens on 80 and redirects to :$PUBLIC_PORT

# Generate secrets once; persist under deploy/.env.prod (chmod 600)
ENV_PROD="${DEPLOY_DIR}/.env.prod"
ORCHESTRATOR_ENV="${ROOT_DIR}/orchestrator/.env"

mkdir -p "${DEPLOY_DIR}"

if [[ ! -f "${ENV_PROD}" ]]; then
  POSTGRES_PASSWORD="pg_$(rand_hex 18)"
  JWT_SECRET="jwt_$(rand_hex 24)"
  ORCHESTRATOR_MODERATOR_API_KEY="mod_$(rand_hex 24)"
  ORCHESTRATOR_WEBHOOK_TOKEN="wh_$(rand_hex 24)"
  GITHUB_WEBHOOK_SECRET="ghwh_$(rand_hex 24)"
  cat >"${ENV_PROD}" <<EOF
# Generated by deploy/deploy.sh
POSTGRES_USER=scix
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
POSTGRES_DB=scix

JWT_SECRET=${JWT_SECRET}

ORCHESTRATOR_MODERATOR_API_KEY=${ORCHESTRATOR_MODERATOR_API_KEY}
ORCHESTRATOR_WEBHOOK_TOKEN=${ORCHESTRATOR_WEBHOOK_TOKEN}
GITHUB_WEBHOOK_SECRET=${GITHUB_WEBHOOK_SECRET}

# Public base used to generate agent claim URLs
BASE_URL=http://${PUBLIC_HOST}:${PUBLIC_PORT}
EOF
  chmod 600 "${ENV_PROD}"
else
  # shellcheck disable=SC1090
  source "${ENV_PROD}"
fi

if [[ ! -f "${ORCHESTRATOR_ENV}" ]]; then
  cat >"${ORCHESTRATOR_ENV}" <<EOF
PORT=8000
APP_ENV=production

# GitHub
GITHUB_TOKEN=${GITHUB_TOKEN}
GITHUB_ORG=${GITHUB_ORG}
GITHUB_API_BASE=https://api.github.com
GITHUB_WEBHOOK_SECRET=${GITHUB_WEBHOOK_SECRET}

# Moderator auth (must match api ORCHESTRATOR_MODERATOR_API_KEY)
MODERATOR_API_KEY=${ORCHESTRATOR_MODERATOR_API_KEY}

# Repo convention
CHALLENGE_REPO_PREFIX=skill
VERSION_BRANCHES=version/v1,version/v2

# Cache
CACHE_TTL_SECONDS=30
CACHE_FILE=data/webhook_cache.json
EOF
  chmod 600 "${SCILAND_ENV}"
else
  echo "INFO: ${SCILAND_ENV} already exists; not overwriting."
fi

# Nginx config: serve web at /, proxy API at /api/v1/
NGINX_CONF="${DEPLOY_DIR}/nginx.conf"
cat >"${NGINX_CONF}" <<EOF
worker_processes  1;

events { worker_connections  1024; }

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;
  sendfile      on;
  keepalive_timeout  65;

  upstream scix_web {
    server web:3000;
  }
  upstream scix_api {
    server api:3002;
  }

  server {
    listen ${PUBLIC_PORT};
    server_name _;

    client_max_body_size 5m;

    location /api/v1/ {
      proxy_pass http://scix_api;
      proxy_set_header Host \$host;
      proxy_set_header X-Real-IP \$remote_addr;
      proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto \$scheme;
    }

    location / {
      proxy_pass http://scix_web;
      proxy_set_header Host \$host;
      proxy_set_header X-Real-IP \$remote_addr;
      proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto \$scheme;
    }
  }

  # Optional: listen on 80 and redirect to :${PUBLIC_PORT}
  server {
    listen 80;
    server_name _;
    if (${REDIRECT_FROM_80}) { return 301 http://${PUBLIC_HOST}:${PUBLIC_PORT}\$request_uri; }
    return 404;
  }
}
EOF

# Compose file (prod-ish): expose only nginx; keep db/redis/orchestrator internal.
COMPOSE_FILE="${DEPLOY_DIR}/docker-compose.prod.yml"
cat >"${COMPOSE_FILE}" <<'EOF'
services:
  db:
    image: postgres:16-alpine
    env_file:
      - ./deploy/.env.prod
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./api/scripts/schema.sql:/docker-entrypoint-initdb.d/001-schema.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 3s
      retries: 30

  redis:
    image: redis:7-alpine

  orchestrator:
    build:
      context: ./orchestrator
      dockerfile: Dockerfile
    env_file:
      - ./orchestrator/.env

  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      orchestrator:
        condition: service_started
    env_file:
      - ./deploy/.env.prod
    environment:
      PORT: 3002
      NODE_ENV: production
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      REDIS_URL: redis://redis:6379
      JWT_SECRET: ${JWT_SECRET}
      BASE_URL: ${BASE_URL}
      ORCHESTRATOR_BASE_URL: http://orchestrator:8000
      ORCHESTRATOR_MODERATOR_API_KEY: ${ORCHESTRATOR_MODERATOR_API_KEY}
      ORCHESTRATOR_WEBHOOK_TOKEN: ${ORCHESTRATOR_WEBHOOK_TOKEN}

  web:
    build:
      context: ./web
      dockerfile: Dockerfile
      args:
        # Use same-origin relative base so nginx can proxy /api/v1/*
        NEXT_PUBLIC_API_BASE_URL: /api/v1
    depends_on:
      api:
        condition: service_started

  nginx:
    image: nginx:1.27-alpine
    depends_on:
      - web
      - api
    volumes:
      - ./deploy/nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "8080:8080"
      - "80:80"

volumes:
  pgdata:
EOF

echo "INFO: building and starting stack..."
cd "${ROOT_DIR}"
dc -f "${COMPOSE_FILE}" up -d --build

echo "INFO: setting strong Postgres password inside container (safe even if it already exists)..."
# Note: changing POSTGRES_PASSWORD does NOT affect an existing cluster; do it explicitly.
set +e
dc -f "${COMPOSE_FILE}" exec -T db psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -v ON_ERROR_STOP=1 \
  -c "ALTER USER ${POSTGRES_USER} WITH PASSWORD '${POSTGRES_PASSWORD}';" >/dev/null 2>&1
set -e

echo
echo "OK."
echo "App:   http://${PUBLIC_HOST}:${PUBLIC_PORT}"
echo "Health http://${PUBLIC_HOST}:${PUBLIC_PORT}/api/v1/health"
echo
echo "Secrets stored in: ${ENV_PROD} (chmod 600)"
echo "Orchestrator env in: ${ORCHESTRATOR_ENV} (chmod 600)"
echo
echo "If using Aliyun security group: allow inbound TCP ${PUBLIC_PORT} (and 80 if you want redirect)."

